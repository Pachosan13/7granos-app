// sync-ventas-v4/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SF_UUID = "1918f8f7-9b5d-4f6a-9b53-a953f82b71ad";

serve(async (req) => {
  const t0 = Date.now();
  try {
    const url = new URL(req.url);
    const mode = url.searchParams.get("mode") ?? "insert"; // ping | diag | insert
    const sucursal = url.searchParams.get("sucursal") ?? "";
    const desde = url.searchParams.get("desde") ?? "";
    const hasta = url.searchParams.get("hasta") ?? "";

    // ✅ modo "ping": sanity check del worker
    if (mode === "ping") {
      return j({ ok: true, mode, now: new Date().toISOString() });
    }

    // ✅ Leer secrets con tus nombres existentes
    const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
    const SERVICE_ROLE = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    // ✅ modo "diag": verificar que los secrets existen
    if (mode === "diag") {
      return j({
        ok: true,
        mode,
        has_SUPABASE_URL: !!SUPABASE_URL,
        has_SUPABASE_SERVICE_ROLE_KEY: !!SERVICE_ROLE,
      });
    }

    // ✅ Verificación básica de headers (solo para insert)
    const auth = req.headers.get("authorization") ?? "";
    if (!auth.toLowerCase().startsWith("bearer ")) {
      return j({ ok: false, error: "Missing/invalid Authorization header" }, 401);
    }

    // ✅ Validar secrets
    if (!SUPABASE_URL || !SERVICE_ROLE) {
      return j({ ok: false, error: "Faltan SUPABASE_URL o SUPABASE_SERVICE_ROLE_KEY" }, 500);
    }

    // ✅ Validar parámetros
    if (!sucursal || !desde || !hasta) {
      return j({ ok: false, error: "Faltan parámetros sucursal|desde|hasta" }, 400);
    }
    if (sucursal !== "sf") {
      return j({ ok: false, error: "Solo SF tiene token vigente" }, 401);
    }

    // ✅ Crear cliente Supabase con service role
    const sb = createClient(SUPABASE_URL, SERVICE_ROLE, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "sync-ventas-v4" } },
    });

    // ✅ Probar conexión
    const { error: probeErr } = await sb.from("ventas").select("id", { count: "exact", head: true }).limit(1);
    if (probeErr) return j({ ok: false, step: "probe", error: probeErr.message ?? probeErr }, 500);

    // ✅ Insertar en ventas
    const venta = {
      sucursal_id: SF_UUID,
      fecha: desde,
      total: 12.34,
      origen: "edge",
    };
    const { error: e1 } = await sb.from("ventas").insert(venta);
    if (e1) return j({ ok: false, step: "ventas", error: e1.message ?? e1 }, 500);

    // ✅ Insertar en ventas_detalle
    const detalle = {
      idorden: crypto.randomUUID(),
      sucursal_id: SF_UUID,
      fecha_cierre: `${desde}T12:00:00Z`,
      estado: "completado",
      subtotal: 12.34,
      itbms: 0,
      total: 12.34,
    };
    const { error: e2 } = await sb.from("ventas_detalle").insert(detalle);
    if (e2) {
      // fallback sin fecha_cierre
      const det2 = {
        idorden: crypto.randomUUID(),
        sucursal_id: SF_UUID,
        created_at: new Date().toISOString(),
        estado: "completado",
        subtotal: 12.34,
        itbms: 0,
        total: 12.34,
      };
      const { error: e2b } = await sb.from("ventas_detalle").insert(det2);
      if (e2b) return j({ ok: false, step: "ventas_detalle", error: e2b.message ?? e2b }, 500);
    }

    // ✅ Respuesta final
    return j({
      ok: true,
      mode,
      note: "Escritura de prueba completada",
      sucursal,
      desde,
      hasta,
      ms: Date.now() - t0,
    });

  } catch (err) {
    return j({ ok: false, error: String(err) }, 500);
  }
});

function j(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json; charset=utf-8" },
  });
}
