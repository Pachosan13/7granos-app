import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SF_UUID = "1918f8f7-9b5d-4f6a-9b53-a953f82b71ad";

serve(async (req) => {
  const t0 = Date.now();
  try {
    const url = new URL(req.url);
    const mode = url.searchParams.get("mode") ?? "insert"; // ping | diag | insert
    const sucursal = url.searchParams.get("sucursal") ?? "";
    const desde = url.searchParams.get("desde") ?? "";
    const hasta = url.searchParams.get("hasta") ?? "";

    // --- ping: sanity de vida del worker (sin headers) ---
    if (mode === "ping") {
      return j({ ok: true, mode, now: new Date().toISOString() });
    }

    // --- leemos secrets con los nombres que YA tenés ---
    const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
    const SERVICE_ROLE  = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    // --- diag: reporta qué secrets ve el worker (sin tocar DB) ---
    if (mode === "diag") {
      return j({
        ok: true,
        mode,
        has_SUPABASE_URL: !!SUPABASE_URL,
        has_SUPABASE_SERVICE_ROLE_KEY: !!SERVICE_ROLE,
      });
    }

    // --- desde aquí pedimos Authorization (la función lo exige) ---
    const auth = req.headers.get("authorization") ?? "";
    if (!auth.toLowerCase().startsWith("bearer ")) {
      return j({ ok:false, error:"Missing/invalid Authorization header" }, 401);
    }

    if (!SUPABASE_URL || !SERVICE_ROLE) {
      return j({ ok:false, error:"Faltan SUPABASE_URL / SUPABASE_SERVICE_ROLE_KEY" }, 500);
    }

    // Validación de params para insert
    if (!sucursal || !desde || !hasta) {
      return j({ ok:false, error:"Faltan parámetros sucursal|desde|hasta" }, 400);
    }
    if (sucursal !== "sf") {
      return j({ ok:false, error:"Solo SF tiene token vigente" }, 401);
    }

    // Cliente server (service role)
    const sb = createClient(SUPABASE_URL, SERVICE_ROLE, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "sync-ventas-v4" } },
    });

    // --- 0) Prueba de conexión/permiso (no toca data)
    // Si acá falla, devolvemos el error real
    {
      const { error: probeErr } = await sb.from("ventas").select("id", { count: "exact", head: true }).limit(1);
      if (probeErr) return j({ ok:false, step:"probe", error: probeErr.message ?? probeErr }, 500);
    }

    // --- 1) INSERT en ventas (TU esquema: no tiene 'estado')
    const venta = {
      sucursal_id: SF_UUID,     // uuid NOT NULL
      fecha: desde,             // date NOT NULL ('YYYY-MM-DD')
      total: 12.34,             // numeric NOT NULL
      origen: "edge",           // opcional (existe en tu tabla)
    };
    const { error: e1 } = await sb.from("ventas").insert(venta);
    if (e1) return j({ ok:false, step:"ventas", error: e1.message ?? e1 }, 500);

    // --- 2) INSERT en ventas_detalle (idorden es NOT NULL)
    const detalle = {
      idorden: crypto.randomUUID(),
      sucursal_id: SF_UUID,
      fecha_cierre: `${desde}T12:05:00Z`, // timestamptz
      estado: "completado",
      subtotal: 12.34,
      itbms: 0,
      total: 12.34,
    };
    const { error: e2 } = await sb.from("ventas_detalle").insert(detalle);
    if (e2) {
      // Fallback si fecha_cierre no pasa
      const det2 = {
        idorden: crypto.randomUUID(),
        sucursal_id: SF_UUID,
        created_at: new Date().toISOString(),
        estado: "completado",
        subtotal: 12.34, itbms: 0, total: 12.34,
      };
      const { error: e2b } = await sb.from("ventas_detalle").insert(det2);
      if (e2b) return j({ ok:false, step:"ventas_detalle", error: e2b.message ?? e2b }, 500);
    }

    return j({
      ok: true,
      mode,
      note: "Escritura de prueba realizada",
      sucursal, desde, hasta,
      ms: Date.now() - t0,
    });

  } catch (err) {
    return j({ ok:false, error: String(err) }, 500);
  }
});

function j(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json; charset=utf-8" },
  });
}
