// deno-lint-ignore-file no-explicit-any
import "jsr:@supabase/functions-js/edge-runtime.d.ts";

type TokenMapEntry = { token: string; invu_location_id?: number };
type TokenMap = Record<string, TokenMapEntry>; // key = sucursal_id (uuid)

type InvuEmpleado = {
  id: number;
  nombres: string;
  apellidos: string;
  identificacion: string | null;
  email: string | null;
};

type Payload = {
  // si viene → sincroniza SOLO esa sucursal
  sucursal_id?: string;
  // si NO viene → sincroniza todas las sucursales definidas en INVU_TOKENS_JSON
};

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const INVU_BASE_URL = Deno.env.get("INVU_BASE_URL") ?? "https://api6.invupos.com/invuApiPos/index.php";
const TOKENS_RAW = Deno.env.get("INVU_TOKENS_JSON") ?? "{}";

const SB_HEADERS = {
  apikey: SERVICE_KEY,
  Authorization: `Bearer ${SERVICE_KEY}`,
  "Content-Type": "application/json",
};

// helpers
const norm = (s: string | null | undefined) => (s ?? "").trim();

async function fetchInvuEmpleados(authToken: string): Promise<InvuEmpleado[]> {
  const url = new URL(INVU_BASE_URL);
  // Muchos tenants exponen la lista como r=empleados
  url.searchParams.set("r", "empleados");

  const res = await fetch(url.toString(), {
    headers: {
      accept: "application/json",
      AUTHORIZATION: authToken,
    },
  });

  if (!res.ok) {
    const t = await res.text();
    throw new Error(`INVU empleados ${res.status}: ${t}`);
  }

  const j = await res.json() as any;
  const data = Array.isArray(j) ? j : (j?.data ?? []);
  return data as InvuEmpleado[];
}

async function upsertChunk(rows: any[]) {
  // Intento directo
  const res = await fetch(`${SUPABASE_URL}/rest/v1/hr_empleado`, {
    method: "POST",
    headers: SB_HEADERS,
    body: JSON.stringify(rows),
  });

  if (res.ok || res.status === 204) return;

  // Conflicto → forzar upsert por índice único que tengas activo
  const res2 = await fetch(
    `${SUPABASE_URL}/rest/v1/hr_empleado?on_conflict=sucursal_id,invu_employee_id`,
    {
      method: "POST",
      headers: SB_HEADERS,
      body: JSON.stringify(rows),
    },
  );
  if (!res2.ok) {
    const t = await res2.text();
    throw new Error(`Upsert hr_empleado fallo: ${res2.status} ${t}`);
  }
}

async function syncOneSucursal(sucursal_id: string, cfg: TokenMapEntry) {
  const empleados = await fetchInvuEmpleados(cfg.token);
  const nowIso = new Date().toISOString();

  // Map → filas hr_empleado
  const rows = empleados.map((e) => ({
    sucursal_id,
    invu_employee_id: e.id,
    empleado_id: String(e.id), // ID externo como string
    nombre: `${norm(e.nombres)} ${norm(e.apellidos)}`.trim() || `Emp ${e.id}`,
    email: norm(e.email) || null,
    invu_identificacion: norm(e.identificacion) || null,
    activo: true,
    last_synced_at: nowIso,
  }));

  // Batch para cargas grandes
  let total = 0;
  const CHUNK = 500;
  for (let i = 0; i < rows.length; i += CHUNK) {
    const chunk = rows.slice(i, i + CHUNK);
    await upsertChunk(chunk);
    total += chunk.length;
  }
  return total;
}

Deno.serve(async (req) => {
  try {
    const payload = (await req.json().catch(() => ({}))) as Payload;

    let tokenMap: TokenMap = {};
    try {
      tokenMap = JSON.parse(TOKENS_RAW);
    } catch {
      tokenMap = {};
    }

    const targets: Array<[string, TokenMapEntry]> = [];

    if (payload.sucursal_id) {
      const cfg = tokenMap[payload.sucursal_id];
      if (!cfg?.token) {
        return new Response(JSON.stringify({
          ok: false,
          error: `No hay token en INVU_TOKENS_JSON para sucursal_id=${payload.sucursal_id}`,
        }), { status: 400, headers: { "content-type": "application/json" } });
      }
      targets.push([payload.sucursal_id, cfg]);
    } else {
      // todas las sucursales que aparezcan en el JSON
      for (const [sucId, cfg] of Object.entries(tokenMap)) {
        if (cfg?.token) targets.push([sucId, cfg]);
      }
      if (targets.length === 0) {
        return new Response(JSON.stringify({
          ok: false,
          error: "INVU_TOKENS_JSON está vacío o malformado.",
        }), { status: 400, headers: { "content-type": "application/json" } });
      }
    }

    const results: Record<string, number> = {};
    for (const [sucId, cfg] of targets) {
      const count = await syncOneSucursal(sucId, cfg);
      results[sucId] = count;
    }

    return new Response(JSON.stringify({ ok: true, results }), {
      headers: { "content-type": "application/json" },
    });
  } catch (e) {
    console.error(e);
    return new Response(JSON.stringify({ ok: false, error: String(e?.message ?? e) }), {
      status: 500,
      headers: { "content-type": "application/json" },
    });
  }
});
